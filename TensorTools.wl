(* ::Package:: *)

BeginPackage[ "TensorTools`"]

  el::usage = 
	"el[i,j,n] gives the n*n matrix with (i,j) element equal to 1";
  KP::usage ="=KroneckerProduct";
  KPPow::usage="KPPow[v,n]=\!\(\*SuperscriptBox[\(v\), \(\(\[TensorProduct]\)\(n\)\)]\)."
  Id::usage ="=IdentityMatrix";
  SVD::usage ="=SingularValueDecomposition.";
  \[Delta]::usage ="=KroneckerDelta";
  H::usage ="H[h,n] construct the n-site Hamiltonian from the local Hamiltonian h.";
  \[CapitalPi]::usage = "\[CapitalPi][n] gives the n*n swap matrix";
  TensorPow::usage = "TensorPow[M,n] gives the n-th tensor power of the tensor M.";
  ContractV::usage = "ContractV[TA,TB] vertically contract the diamond-shaped tensors TA, TB. Index order: {top, left, right, bottom}";
  ContractH::usage = "ContractH[TA,TB] horizontally contract the tensors TA and TB, where either both are diamond shaped or both are triangle shaped.";
  ContractY::usage = "ContractY[Y1,Y2] vertically contract the two Y-triangles Y1,Y2.";
  ContractH41::usage="ContractH41[TA,v] Horizontally contract 4-index TA and vector v.";
  ContractH14::usage="ContractH14[v,TA] Horizontally contract vector v and 4-index TA.";
  V2H::usage = "Swap between vertical indexing convention to horizontal indexing convention.";
  partialTr::usage= "For a d1 d2 * d1 d2 matrix M, partialTr[M,d1,d2] take the partial trace in the first tensor factor space, and obtain a d2*d2 matrix."
  partialTrR::usage= "For a d1 d2 * d1 d2 matrix M, partialTr[M,d1,d2] take the partial trace in the second tensor factor space, and obtain a d1*d1 matrix."
  pTrL::usage = "pTrL[\[Rho],d,k,n] take partial trace of the left subsystem.";
  pTrR::usage = "pTrR[\[Rho],d,k,n] take partial trace of the right subsystem.";
  Tdagger::usage="Tdagger[T] computes the conjugate transpose of the 4-index tensor T in the quantum direction (no transpose in the virtual direction).";
  TM\[Psi]::usage="TM\[Psi][\[Psi]] computes the TM of the MPS generating tensor \[Psi]";
  TMO\[Psi]::usage="TMO\[Psi][O,\[Psi]] computes the TM of the MPS generating tensor \[Psi] with observable O inserted.";
  MatrixPow::usage="Matrix power, return Id if n==0.";
  SwapX::usage="SwapX[A,d1,d2] swaps the two tensor factors of a d1*d2-dimensional square matrix A, 
             where d1 and d2 are the dimensions of the two tensor factors to be swapped.";
  ProductStateMPS::usage="ProductStateMPS[\[Psi]\[Rho]0,\[Psi]v0] constructs a trivial MPS from a product state (\[Psi]\[Rho]0\[TensorProduct]\[Psi]v0\!\(\*SuperscriptBox[\()\), \(\(\[TensorProduct]\)\(N\)\)]\).";
  SwapTensor::usage="SwapTensor[d1,d2] gives the 4-index swap tensor, where d1 is the vertical dimension and d2 is the horizontal dimension.";
  IsPerfectTensor::usage="IsPerfectTensor[U] checks if U is a perfect tensor";
  DualTensor::usage="DualTensor[U] gives the space-time dual of U, going from left to right";
  DiagonalTensor::usage="DiagonalTensor[U] gives the diagonal dual of U, going from 14 to 23";
  SquareTN::usage="SquareTN[U,m] gives the m*m square tensor network generated by U.";
  Begin[ "Private`"]
	el[i_,j_,n_]:=el[i,j,n]=Module[{M=ConstantArray[0,{n,n},SparseArray]},M[[i,j]]=1;M];
	KP=KroneckerProduct;
	KPPow[v_,n_]:=If[n==1,v,KP[v,KPPow[v,n-1]]];
	Id=IdentityMatrix;
	SVD=SingularValueDecomposition;
	\[Delta]=KroneckerDelta;
	H[h_,n_]:=Module[{d=Sqrt[Length[h]]},If[n==2, h,KP[H[h,n-1],Id[d,SparseArray]]+KP[Id[d^(n-2),SparseArray], h]]];
	\[CapitalPi][n_]:=\[CapitalPi][n]=Sum[KP[el[i,j,n],el[j,i,n]],{i,1,n},{j,1,n}];
	SwapX[A_,d1_,d2_]:=ArrayReshape[Transpose[ArrayReshape[A,{d1,d2,d1,d2}],{2,1,4,3}],{d1 d2, d1 d2}];
	TensorPow[M_,n_]:=If[n==1,M,M.TensorPow[M,n-1]];
	MatrixPow[M_,n_]:=If[n ==0,Id[Dimensions[M][[1]],SparseArray],MatrixPower[M,n]];
	ContractY[Y1_,Y2_]:=Module[{m,d},
		{m,d,d}=Dimensions[Y1];
		Transpose[ArrayReshape[Transpose[Y1,1<->2].Transpose[Y2,1<->2],{d,m^2,d}],2<-> 3]
	];
	ContractV[TA_,TB_]:=Flatten[TA.TB,{{1},{2,4},{3,5}}];(*Warning: TA is assumed to have 4 indices. TB can have 4 or 3 indices.*)
	V2H[T_]:=Transpose[T,{2,1,4,3}];
	ContractH44[TA_,TB_]:=V2H[ContractV[V2H[TA],V2H[TB]]];
	ContractH33[TA_,TB_]:=Transpose@Flatten[Transpose[TA].Transpose[TB],{{1},{2,3},{4}}];
	ContractH41[TA_,v_]:=Transpose[TA,3<->4].v;
	ContractH14[v_,TA_]:=v.Transpose[TA,1<->2];
	
	ContractH[TA_,TB_]:=If[ArrayDepth[TB]==3,ContractH33[TA,TB],ContractH44[TA,TB]];(*Note that we assume that TA and TB both have 3 indices or both have 4 indices*)
	partialTr[M_,d1_,d2_]:=Flatten[Id[d1,SparseArray]].ArrayReshape[Transpose[ArrayReshape[M,{d1,d2,d1,d2}],2<->3],{d1^2,d2,d2}];
	partialTrR[M_,d1_,d2_]:=ArrayReshape[Transpose[ArrayReshape[M,{d1,d2,d1,d2}],2<->3],{d1,d1,d2^2}].Flatten[Id[d2,SparseArray]];
	pTrL[\[Rho]_,d_,k_,n_]:=partialTr[\[Rho],d^k,d^(n-k)];
	pTrR[\[Rho]_,d_,k_,n_]:=partialTrR[\[Rho],d^k,d^(n-k)];
	Tdagger[T_]:=Conjugate@Transpose[T,1<->4];
    TMO\[Psi][O_,\[Psi]_]:=Module[{\[Psi]d},
    \[Psi]d=Conjugate@Transpose[\[Psi],{3,1,2}];
    Flatten[\[Psi]d.O.\[Psi],{{1,3},{2,4}}]
    ];
    TM\[Psi][\[Psi]_]:=Module[{d=Dimensions[\[Psi]][[1]]},
    TMO\[Psi][Id[d,SparseArray],\[Psi]]
    ];
    ProductStateMPS[\[Psi]\[Rho]0_,\[Psi]v0_]:=Module[{d\[Rho],dv,\[Chi]L,\[Chi]R,\[Psi]\[Rho],\[Psi]v},
    \[Chi]L=\[Chi]R={1};
    {d\[Rho],dv}=Length/@{\[Psi]\[Rho]0,\[Psi]v0};
    \[Psi]\[Rho]=ArrayReshape[\[Psi]\[Rho]0,{d\[Rho],1,1}]/Norm[\[Psi]\[Rho]0];
    \[Psi]v=ArrayReshape[\[Psi]v0,{d\[Rho],1,1}]/Norm[\[Psi]v0];
    {\[Chi]L,\[Chi]R,\[Psi]\[Rho],\[Psi]v}
    ];
    SwapTensor[d1_,d2_]:=Transpose[ArrayReshape[Id[d1 d2,SparseArray],{d1,d2,d1,d2}],3<->4];
    DualTensor[U_]:=Module[{d=Sqrt[Length@U]},Flatten[ArrayReshape[U,{d,d,d,d}],{{1,3},{2,4}}]];
    DiagonalTensor[U_]:=Module[{d=Sqrt[Length@U]},Flatten[ArrayReshape[U,{d,d,d,d}],{{1,4},{2,3}}]];
    IsPerfectTensor[U_]:=Module[{d=Sqrt[Length@U]},
    {UnitaryMatrixQ[U],UnitaryMatrixQ[DualTensor[U]],UnitaryMatrixQ[DiagonalTensor[U]]}
    ];
    
(*Note: in the following EDtools, we only consider the simple case d\[Rho]=dv*)
RowTM[U_,k_,m_]:=RowTM[U,k,m]=Module[{d=Sqrt[Dimensions[U][[1]]],n=2m,U0,j},
U0=1.0*Id[d^(m-k),SparseArray];
For[j=1,j<= k,j++ ,
U0=KP[U0,U];
];
KP[U0,Id[d^(m-k),SparseArray]]
];

\[CapitalPsi]t[U_,m_,t_,\[CapitalPsi]0_]:=Module[{d=Sqrt[Dimensions[U][[1]]],n=2m,k},
For[k=m,k>=m-t+1,k-- ,
\[CapitalPsi]0=RowTM[U,k,m].\[CapitalPsi]0;
];
\[CapitalPsi]0
];
SquareTN[U_,m_]:=Module[{U0,n=2m,k},
U0=RowTM[U,m,m];
For[k=m-1,k>=1,k-- ,
U0=RowTM[U,k,m].U0.RowTM[U,k,m];
];
U0
];

LowerTriangleTN[U_,m_]:=LowerTriangleTN[U,m]=Module[{U0,n=2m,k},
U0=RowTM[U,m,m];
For[k=m-1,k>=1,k-- ,
U0=RowTM[U,k,m].U0;
];
U0
];
UpperTriangleTN[U_,m_]:=UpperTriangleTN[U,m]=Module[{U0,n=2m,k},
U0=RowTM[U,m,m];
For[k=m-1,k>=1,k-- ,
U0=U0.RowTM[U,k,m];
];
U0
];


(*  TM\[Psi][T_,\[Psi]_]:=Module[{\[Psi]1,\[Psi]1s},
  \[Psi]1=ContractV[T,\[Psi]];
  \[Psi]1s=Conjugate@Transpose[\[Psi]1,{3,1,2}];
  Flatten[\[Psi]1s.\[Psi]1,{{1,3},{2,4}}]
  ];*)
  End[]

  EndPackage[]

